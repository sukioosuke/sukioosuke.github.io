{"meta":{"title":"Suki's Blog","subtitle":null,"description":null,"author":"Suki","url":"https://sukioosuke.github.io"},"posts":[{"title":"oj-cpp-bits","slug":"oj-cpp-bits","date":"2019-07-08T03:20:54.000Z","updated":"2019-07-08T03:33:38.888Z","comments":true,"path":"2019/07/08/oj-cpp-bits/","link":"","permalink":"https://sukioosuke.github.io/2019/07/08/oj-cpp-bits/","excerpt":"","text":"在OJ中经常能看到C++使用头文件&lt;bits/stdc++.h&gt;，但是在本地使用简易编译器时，经常会报找不到该文件。这个文件是属于MinGW中的一个，如果安装了MinGW的直接在文件夹里面找到bits这个文件夹（注意里面一定要包含stdc++.h，有可能有两个bits文件夹），把里面内容复制粘贴到vs的头文件库（一般是在安装目录）里面。如果没有安装MinGW，在自己vs的includ目录里新建一个bits文件夹，里面新建一个名叫stdc++.h的头文件（ubuntu一般是在user/include下面），里面写你常用的头文件，这里我搬运一下stdc++.h源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// C++ includes used for precompiling -*- C++ -*-// Copyright (C) 2003-2015 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library. This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version.// This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the// GNU General Public License for more details.// Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation.// You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively. If not, see// &lt;http://www.gnu.org/licenses/&gt;./** @file stdc++.h * This is an implementation file for a precompiled header. */// 17.4.1.2 Headers// C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif// C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;#if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif","raw":null,"content":null,"categories":[{"name":"OJ","slug":"OJ","permalink":"https://sukioosuke.github.io/categories/OJ/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://sukioosuke.github.io/tags/C/"},{"name":"OJ","slug":"OJ","permalink":"https://sukioosuke.github.io/tags/OJ/"}]},{"title":"python中的yield关键字","slug":"python-yield","date":"2019-07-02T08:47:06.000Z","updated":"2019-07-04T03:29:17.371Z","comments":true,"path":"2019/07/02/python-yield/","link":"","permalink":"https://sukioosuke.github.io/2019/07/02/python-yield/","excerpt":"","text":"今天在看别人的代码时遇到了yield关键字，当时学python的时候学的并不扎实，现在做个总结 1.yield example一个网上经常列举的yield的例子： 12345def node._get_child_candidates(self, distance, min_dist, max_dist): if self._leftchild and distance - max_dist &lt; self._median: yield self._leftchild if self._rightchild and distance + max_dist &gt;= self._median: yield self._rightchild 下面是具体调用时的执行 12345678result, candidates = list(), [self]while candidates: node = candidates.pop() distance = node._get_dist(obj) if distance &lt;= max_dist and distance &gt;= min_dist: result.extend(node._values) candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))return result 调用_get_child_candidates时，返回了一个child的合集（list），yield是如何生成这个对象的呢？ 2.先来看一下可迭代对象当你建立了一个列表，你可以逐项地读取这个列表，这叫做一个可迭代对象: 123456&gt;&gt;&gt; mylist = [1, 2, 3]&gt;&gt;&gt; for i in mylist :... print(i)123 mylist是一个可迭代的对象。当你使用一个列表生成式来建立一个列表的时候，同样生成了一个可迭代的对象: 123456&gt;&gt;&gt; mylist = [x for x in range(3)]&gt;&gt;&gt; for i in mylist :... print(i)012 可以通过for循环读取的对象就是一个迭代器，其元素在遍历访问时均存储在了内存中，如果要大量访问数据的话，迭代器的方式是很占用资源的 3.生成器生成器是可以迭代的对象，但是你只需读取一次，它可以在调用时实时生成数据，而不是将数据都存放在内存中。 123456&gt;&gt;&gt; mygenerator = (x for x in range(3))&gt;&gt;&gt; for i in mygenerator :... print(i)012 虽然只是把(换成了[，但是对于生成器而言，只能迭代一次，而且也从迭代器变成了生成器。 4.回到yield关键字yield关键字在调用后会返回一个类似于mygenerator的生成器，类似于返回生成器的return关键字。 12345678910111213&gt;&gt;&gt; def createGenerator() :... mylist = range(3)... for i in mylist :... yield i*i...&gt;&gt;&gt; mygenerator = createGenerator() # create a generator&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!&lt;generator object createGenerator at 0xb7555c34&gt;&gt;&gt;&gt; for i in mygenerator:... print(i)014 在执行for i in mygenerator时，到达yield关键字时，返回yield后的值作为第一次迭代的返回值. 然后，每次执行这个函数都会继续返回定义的迭代值，直到没有可以返回的。带有yield的函数不仅仅只用于for循环中，而且可用于某个函数的参数，只要这个函数的参数允许迭代参数。比如array.extend函数，它的原型是array.extend(iterable)。 此处应注意的是，生成器的方法虽然可以调用多次，获取多个迭代结果，但生成器只会实例化一次，既实例化后的生成器可以通过变量等来控制生成器的生成与穷尽。可参考如下代码： 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; class Bank(): # let's create a bank, building ATMs... crisis = False... def create_atm(self) :... while not self.crisis :... yield \"$100\"&gt;&gt;&gt; hsbc = Bank() # when everything's ok the ATM gives you as much as you want&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()&gt;&gt;&gt; print(corner_street_atm.__next__()())$100&gt;&gt;&gt; print(corner_street_atm.__next__()())$100&gt;&gt;&gt; print([corner_street_atm.__next__()() for cash in range(5)])['$100', '$100', '$100', '$100', '$100']&gt;&gt;&gt; hsbc.crisis = True # crisis is coming, no more money!&gt;&gt;&gt; print(corner_street_atm.__next__()())&lt;type 'exceptions.StopIteration'&gt;&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # it's even true for new ATMs&gt;&gt;&gt; print(wall_street_atm.__next__()())&lt;type 'exceptions.StopIteration'&gt;&gt;&gt;&gt; hsbc.crisis = False # trouble is, even post-crisis the ATM remains empty&gt;&gt;&gt; print(corner_street_atm.__next__()())&lt;type 'exceptions.StopIteration'&gt;&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # build a new one to get back in business&gt;&gt;&gt; for cash in brand_new_atm :... print cash$100$100$100$100$100$100$100$100$100... 5.迭代器的操作生成器只能实例化一次，这就为我们的复用造成一些麻烦，如果需要两个一模一样但是相互独立的生成器怎么办呢？itertools提供了很多特殊的迭代方法，包括复制一个迭代器，串联迭代器，把嵌套的列表分组等等等，这个类从一定程度上解决了生成器的复用问题。如果想要动态变化生成器的内容呢？生成器本身除去next方法外，还有一个send(msg)的方法，send(msg)与next()的区别在于send可以传递参数给yield表达式，这时传递的参数会作为yield表达式的值，而yield的参数是返回给调用者的值。比如函数中有一个yield赋值，a = yield 5，第一次迭代到这里会返回5，a还没有赋值。第二次迭代时，使用.send(10)，那么，就是强行修改yield 5表达式的值为10，本来是5的，而现在a=10。可以认为，next()等同于send(None)。 此处应注意的是，第一次调用时必须先next()或send(None)，否则会报错，因为这时候没有上一个yield值。 6.关于迭代器的内部原理迭代是一个实现可迭代对象(实现的是__iter__()方法)和迭代器(实现的是__next__()方法)的过程。可迭代对象是你可以从其获取到一个迭代器的任一对象。迭代器是那些允许你迭代可迭代对象的对象。 参考文献：https://pyzh.readthedocs.io/en/latest/the-python-yield-keyword-explained.html#yield","raw":null,"content":null,"categories":[{"name":"python","slug":"python","permalink":"https://sukioosuke.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sukioosuke.github.io/tags/python/"}]},{"title":"Hello World!","slug":"Hello-World","date":"2019-06-25T09:39:24.000Z","updated":"2019-06-27T09:28:09.064Z","comments":true,"path":"2019/06/25/Hello-World/","link":"","permalink":"https://sukioosuke.github.io/2019/06/25/Hello-World/","excerpt":"","text":"之前一直想找个工具记录一下自己的所学所想，开始在csdn做简单的记录，后来改版后每次写的时候都要花费不少功夫要写，就慢慢放弃了。这次在git用hexo自建blog，可以避免这个问题，也可以让自己坚持下去。blog主要用于： 整理知识，学习笔记 发布日记，杂文，所见所想 整理技术文稿（代码） 别人的赏识都是过眼云烟，只有自己的提高进步才是真金白银！ p.s. 在线md编写工具","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"https://sukioosuke.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://sukioosuke.github.io/tags/随笔/"}]}]}