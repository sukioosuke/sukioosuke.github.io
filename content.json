{"meta":{"title":"Suki's Blog","subtitle":null,"description":null,"author":"Suki","url":"https://sukioosuke.github.io"},"posts":[{"title":"python中的yield关键字","slug":"python-yield","date":"2019-07-02T08:47:06.000Z","updated":"2019-07-04T03:29:17.371Z","comments":true,"path":"2019/07/02/python-yield/","link":"","permalink":"https://sukioosuke.github.io/2019/07/02/python-yield/","excerpt":"","text":"今天在看别人的代码时遇到了yield关键字，当时学python的时候学的并不扎实，现在做个总结 1.yield example一个网上经常列举的yield的例子： 12345def node._get_child_candidates(self, distance, min_dist, max_dist): if self._leftchild and distance - max_dist &lt; self._median: yield self._leftchild if self._rightchild and distance + max_dist &gt;= self._median: yield self._rightchild 下面是具体调用时的执行 12345678result, candidates = list(), [self]while candidates: node = candidates.pop() distance = node._get_dist(obj) if distance &lt;= max_dist and distance &gt;= min_dist: result.extend(node._values) candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))return result 调用_get_child_candidates时，返回了一个child的合集（list），yield是如何生成这个对象的呢？ 2.先来看一下可迭代对象当你建立了一个列表，你可以逐项地读取这个列表，这叫做一个可迭代对象: 123456&gt;&gt;&gt; mylist = [1, 2, 3]&gt;&gt;&gt; for i in mylist :... print(i)123 mylist是一个可迭代的对象。当你使用一个列表生成式来建立一个列表的时候，同样生成了一个可迭代的对象: 123456&gt;&gt;&gt; mylist = [x for x in range(3)]&gt;&gt;&gt; for i in mylist :... print(i)012 可以通过for循环读取的对象就是一个迭代器，其元素在遍历访问时均存储在了内存中，如果要大量访问数据的话，迭代器的方式是很占用资源的 3.生成器生成器是可以迭代的对象，但是你只需读取一次，它可以在调用时实时生成数据，而不是将数据都存放在内存中。 123456&gt;&gt;&gt; mygenerator = (x for x in range(3))&gt;&gt;&gt; for i in mygenerator :... print(i)012 虽然只是把(换成了[，但是对于生成器而言，只能迭代一次，而且也从迭代器变成了生成器。 4.回到yield关键字yield关键字在调用后会返回一个类似于mygenerator的生成器，类似于返回生成器的return关键字。 12345678910111213&gt;&gt;&gt; def createGenerator() :... mylist = range(3)... for i in mylist :... yield i*i...&gt;&gt;&gt; mygenerator = createGenerator() # create a generator&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!&lt;generator object createGenerator at 0xb7555c34&gt;&gt;&gt;&gt; for i in mygenerator:... print(i)014 在执行for i in mygenerator时，到达yield关键字时，返回yield后的值作为第一次迭代的返回值. 然后，每次执行这个函数都会继续返回定义的迭代值，直到没有可以返回的。带有yield的函数不仅仅只用于for循环中，而且可用于某个函数的参数，只要这个函数的参数允许迭代参数。比如array.extend函数，它的原型是array.extend(iterable)。 此处应注意的是，生成器的方法虽然可以调用多次，获取多个迭代结果，但生成器只会实例化一次，既实例化后的生成器可以通过变量等来控制生成器的生成与穷尽。可参考如下代码： 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; class Bank(): # let's create a bank, building ATMs... crisis = False... def create_atm(self) :... while not self.crisis :... yield \"$100\"&gt;&gt;&gt; hsbc = Bank() # when everything's ok the ATM gives you as much as you want&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()&gt;&gt;&gt; print(corner_street_atm.__next__()())$100&gt;&gt;&gt; print(corner_street_atm.__next__()())$100&gt;&gt;&gt; print([corner_street_atm.__next__()() for cash in range(5)])['$100', '$100', '$100', '$100', '$100']&gt;&gt;&gt; hsbc.crisis = True # crisis is coming, no more money!&gt;&gt;&gt; print(corner_street_atm.__next__()())&lt;type 'exceptions.StopIteration'&gt;&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # it's even true for new ATMs&gt;&gt;&gt; print(wall_street_atm.__next__()())&lt;type 'exceptions.StopIteration'&gt;&gt;&gt;&gt; hsbc.crisis = False # trouble is, even post-crisis the ATM remains empty&gt;&gt;&gt; print(corner_street_atm.__next__()())&lt;type 'exceptions.StopIteration'&gt;&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # build a new one to get back in business&gt;&gt;&gt; for cash in brand_new_atm :... print cash$100$100$100$100$100$100$100$100$100... 5.迭代器的操作生成器只能实例化一次，这就为我们的复用造成一些麻烦，如果需要两个一模一样但是相互独立的生成器怎么办呢？itertools提供了很多特殊的迭代方法，包括复制一个迭代器，串联迭代器，把嵌套的列表分组等等等，这个类从一定程度上解决了生成器的复用问题。如果想要动态变化生成器的内容呢？生成器本身除去next方法外，还有一个send(msg)的方法，send(msg)与next()的区别在于send可以传递参数给yield表达式，这时传递的参数会作为yield表达式的值，而yield的参数是返回给调用者的值。比如函数中有一个yield赋值，a = yield 5，第一次迭代到这里会返回5，a还没有赋值。第二次迭代时，使用.send(10)，那么，就是强行修改yield 5表达式的值为10，本来是5的，而现在a=10。可以认为，next()等同于send(None)。 此处应注意的是，第一次调用时必须先next()或send(None)，否则会报错，因为这时候没有上一个yield值。 6.关于迭代器的内部原理迭代是一个实现可迭代对象(实现的是__iter__()方法)和迭代器(实现的是__next__()方法)的过程。可迭代对象是你可以从其获取到一个迭代器的任一对象。迭代器是那些允许你迭代可迭代对象的对象。 参考文献：https://pyzh.readthedocs.io/en/latest/the-python-yield-keyword-explained.html#yield","raw":null,"content":null,"categories":[{"name":"python","slug":"python","permalink":"https://sukioosuke.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sukioosuke.github.io/tags/python/"}]},{"title":"Hello World!","slug":"Hello-World","date":"2019-06-25T09:39:24.000Z","updated":"2019-06-27T09:28:09.064Z","comments":true,"path":"2019/06/25/Hello-World/","link":"","permalink":"https://sukioosuke.github.io/2019/06/25/Hello-World/","excerpt":"","text":"之前一直想找个工具记录一下自己的所学所想，开始在csdn做简单的记录，后来改版后每次写的时候都要花费不少功夫要写，就慢慢放弃了。这次在git用hexo自建blog，可以避免这个问题，也可以让自己坚持下去。blog主要用于： 整理知识，学习笔记 发布日记，杂文，所见所想 整理技术文稿（代码） 别人的赏识都是过眼云烟，只有自己的提高进步才是真金白银！ p.s. 在线md编写工具","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"https://sukioosuke.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://sukioosuke.github.io/tags/随笔/"}]}]}