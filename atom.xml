<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Suki&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sukioosuke.github.io/"/>
  <updated>2019-07-04T03:29:17.371Z</updated>
  <id>https://sukioosuke.github.io/</id>
  
  <author>
    <name>Suki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python中的yield关键字</title>
    <link href="https://sukioosuke.github.io/2019/07/02/python-yield/"/>
    <id>https://sukioosuke.github.io/2019/07/02/python-yield/</id>
    <published>2019-07-02T08:47:06.000Z</published>
    <updated>2019-07-04T03:29:17.371Z</updated>
    
    <content type="html"><![CDATA[<p>今天在看别人的代码时遇到了yield关键字，当时学python的时候学的并不扎实，现在做个总结</p><h3 id="1-yield-example"><a href="#1-yield-example" class="headerlink" title="1.yield example"></a>1.yield example</h3><p>一个网上经常列举的yield的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span>.<span class="title">_get_child_candidates</span><span class="params">(self, distance, min_dist, max_dist)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._leftchild <span class="keyword">and</span> distance - max_dist &lt; self._median:</span><br><span class="line">        <span class="keyword">yield</span> self._leftchild</span><br><span class="line">    <span class="keyword">if</span> self._rightchild <span class="keyword">and</span> distance + max_dist &gt;= self._median:</span><br><span class="line">        <span class="keyword">yield</span> self._rightchild</span><br></pre></td></tr></table></figure><p>下面是具体调用时的执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">result, candidates = list(), [self]</span><br><span class="line"><span class="keyword">while</span> candidates:</span><br><span class="line">    node = candidates.pop()</span><br><span class="line">    distance = node._get_dist(obj)</span><br><span class="line">    <span class="keyword">if</span> distance &lt;= max_dist <span class="keyword">and</span> distance &gt;= min_dist:</span><br><span class="line">        result.extend(node._values)</span><br><span class="line">    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>调用_get_child_candidates时，返回了一个child的合集（list），yield是如何生成这个对象的呢？</p><h3 id="2-先来看一下可迭代对象"><a href="#2-先来看一下可迭代对象" class="headerlink" title="2.先来看一下可迭代对象"></a>2.先来看一下可迭代对象</h3><p>当你建立了一个列表，你可以逐项地读取这个列表，这叫做一个可迭代对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist :</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>mylist</code>是一个可迭代的对象。当你使用一个列表生成式来建立一个列表的时候，同样生成了一个可迭代的对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist :</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以通过<code>for</code>循环读取的对象就是一个迭代器，其元素在遍历访问时均存储在了内存中，如果要大量访问数据的话，迭代器的方式是很占用资源的</p><h3 id="3-生成器"><a href="#3-生成器" class="headerlink" title="3.生成器"></a>3.生成器</h3><p>生成器是可以迭代的对象，但是你<strong>只需读取一次</strong>，它可以在调用时实时生成数据，而不是将数据都存放在内存中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = (x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator :</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>虽然只是把(换成了[，但是对于生成器而言，只能迭代一次，而且也从迭代器变成了生成器。</p><h3 id="4-回到yield关键字"><a href="#4-回到yield关键字" class="headerlink" title="4.回到yield关键字"></a>4.回到yield关键字</h3><p><code>yield</code>关键字在调用后会返回一个类似于<code>mygenerator</code>的生成器，类似于返回生成器的<code>return</code>关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span><span class="params">()</span> :</span></span><br><span class="line"><span class="meta">... </span>   mylist = range(<span class="number">3</span>)</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">for</span> i <span class="keyword">in</span> mylist :</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">yield</span> i*i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = createGenerator() <span class="comment"># create a generator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(mygenerator) <span class="comment"># mygenerator is an object!</span></span><br><span class="line">&lt;generator object createGenerator at <span class="number">0xb7555c34</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>在执行<code>for i in mygenerator</code>时，到达<code>yield</code>关键字时，返回<code>yield</code>后的值作为第一次迭代的返回值. 然后，每次执行这个函数都会继续返回定义的迭代值，直到没有可以返回的。带有yield的函数不仅仅只用于for循环中，而且可用于某个函数的参数，只要这个函数的参数允许迭代参数。比如<code>array.extend</code>函数，它的原型是<code>array.extend(iterable)</code>。此处应注意的是，生成器的方法虽然可以调用多次，获取多个迭代结果，但生成器只会实例化一次，既实例化后的生成器可以通过变量等来控制生成器的生成与穷尽。可参考如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bank</span><span class="params">()</span>:</span> <span class="comment"># let's create a bank, building ATMs</span></span><br><span class="line"><span class="meta">... </span>   crisis = <span class="literal">False</span></span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">create_atm</span><span class="params">(self)</span> :</span></span><br><span class="line"><span class="meta">... </span>       <span class="keyword">while</span> <span class="keyword">not</span> self.crisis :</span><br><span class="line"><span class="meta">... </span>           <span class="keyword">yield</span> <span class="string">"$100"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc = Bank() <span class="comment"># when everything's ok the ATM gives you as much as you want</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>corner_street_atm = hsbc.create_atm()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.__next__()())</span><br><span class="line">$<span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.__next__()())</span><br><span class="line">$<span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([corner_street_atm.__next__()() <span class="keyword">for</span> cash <span class="keyword">in</span> range(<span class="number">5</span>)])</span><br><span class="line">[<span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc.crisis = <span class="literal">True</span> <span class="comment"># crisis is coming, no more money!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.__next__()())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wall_street_atm = hsbc.create_atm() <span class="comment"># it's even true for new ATMs</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(wall_street_atm.__next__()())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc.crisis = <span class="literal">False</span> <span class="comment"># trouble is, even post-crisis the ATM remains empty</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.__next__()())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>brand_new_atm = hsbc.create_atm() <span class="comment"># build a new one to get back in business</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> cash <span class="keyword">in</span> brand_new_atm :</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">print</span> cash</span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="5-迭代器的操作"><a href="#5-迭代器的操作" class="headerlink" title="5.迭代器的操作"></a>5.迭代器的操作</h3><p>生成器只能实例化一次，这就为我们的复用造成一些麻烦，如果需要两个一模一样但是相互独立的生成器怎么办呢？<br>itertools提供了很多特殊的迭代方法，包括复制一个迭代器，串联迭代器，把嵌套的列表分组等等等，这个类从一定程度上解决了生成器的复用问题。<br>如果想要动态变化生成器的内容呢？生成器本身除去next方法外，还有一个send(msg)的方法，send(msg)与next()的区别在于send可以传递参数给yield表达式，这时传递的参数会作为yield表达式的值，而yield的参数是返回给调用者的值。比如函数中有一个yield赋值，<code>a = yield 5</code>，第一次迭代到这里会返回5，a还没有赋值。第二次迭代时，使用<code>.send(10)</code>，那么，就是强行修改yield 5表达式的值为10，本来是5的，而现在<code>a=10</code>。可以认为，next()等同于send(None)。</p><blockquote><p>此处应注意的是，第一次调用时必须先next()或send(None)，否则会报错，因为这时候没有上一个yield值。</p></blockquote><h3 id="6-关于迭代器的内部原理"><a href="#6-关于迭代器的内部原理" class="headerlink" title="6.关于迭代器的内部原理"></a>6.关于迭代器的内部原理</h3><p>迭代是一个实现可迭代对象(实现的是<code>__iter__()</code>方法)和迭代器(实现的是<code>__next__()</code>方法)的过程。可迭代对象是你可以从其获取到一个迭代器的任一对象。迭代器是那些允许你迭代可迭代对象的对象。</p><p>参考文献：<a href="https://pyzh.readthedocs.io/en/latest/the-python-yield-keyword-explained.html#yield" target="_blank" rel="noopener">https://pyzh.readthedocs.io/en/latest/the-python-yield-keyword-explained.html#yield</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在看别人的代码时遇到了yield关键字，当时学python的时候学的并不扎实，现在做个总结&lt;/p&gt;
&lt;h3 id=&quot;1-yield-example&quot;&gt;&lt;a href=&quot;#1-yield-example&quot; class=&quot;headerlink&quot; title=&quot;1.yield
      
    
    </summary>
    
      <category term="python" scheme="https://sukioosuke.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sukioosuke.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World!</title>
    <link href="https://sukioosuke.github.io/2019/06/25/Hello-World/"/>
    <id>https://sukioosuke.github.io/2019/06/25/Hello-World/</id>
    <published>2019-06-25T09:39:24.000Z</published>
    <updated>2019-06-27T09:28:09.064Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直想找个工具记录一下自己的所学所想，开始在csdn做简单的记录，后来改版后每次写的时候都要花费不少功夫要写，就慢慢放弃了。这次在git用hexo自建blog，可以避免这个问题，也可以让自己坚持下去。<br>blog主要用于：</p><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>整理技术文稿（代码）</li></ul></blockquote><p>别人的赏识都是过眼云烟，只有自己的提高进步才是真金白银！</p><p>p.s. <a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">在线md编写工具</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直想找个工具记录一下自己的所学所想，开始在csdn做简单的记录，后来改版后每次写的时候都要花费不少功夫要写，就慢慢放弃了。这次在git用hexo自建blog，可以避免这个问题，也可以让自己坚持下去。&lt;br&gt;blog主要用于：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="随笔" scheme="https://sukioosuke.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://sukioosuke.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
